"use client"

import { useEffect, useRef } from "react"
import { motion } from "framer-motion"

interface Bubble {
  id: number
  x: number
  y: number
  vx: number
  vy: number
  radius: number
  skill: string
  color: string
  category: string
}

interface SkillData {
  name: string
  category: string
  connections: string[]
}

const skillsData: SkillData[] = [
  // Programming Languages
  {
    name: "Python",
    category: "programming",
    connections: ["Pandas", "NumPy", "Matplotlib", "Seaborn", "Machine Learning", "Deep Learning", "NLP"],
  },
  {
    name: "R",
    category: "programming",
    connections: ["Statistics", "Regression", "Time Series", "Hypothesis Testing"],
  },
  { name: "Java", category: "programming", connections: ["SQL", "Classification"] },
  { name: "SQL", category: "programming", connections: ["MySQL", "PostgreSQL", "Data Mining", "Java"] },
  { name: "Julia", category: "programming", connections: ["Python", "NumPy", "Pandas"] },
  { name: "C", category: "programming", connections: ["C++", "Algorithms"] },
  { name: "C++", category: "programming", connections: ["C", "Algorithms"] },
  { name: "Git", category: "programming", connections: ["CI/CD", "Docker"] },


  // Databases
  { name: "MySQL", category: "database", connections: ["SQL", "PostgreSQL", "Data Mining"] },
  { name: "PostgreSQL", category: "database", connections: ["SQL", "MySQL", "Python"] },
  { name: "SQL Server", category: "database", connections: ["SQL"] },
  { name: "SQLite", category: "database", connections: ["SQL"] },
  { name: "Databricks", category: "database", connections: ["PySpark", "SQL"] },
  { name: "PySpark", category: "database", connections: ["Databricks", "SQL"] },


  // Analytics & Visualization
  { name: "Pandas", category: "analytics", connections: ["Python", "NumPy", "Data Mining", "Statistics"] },
  { name: "NumPy", category: "analytics", connections: ["Python", "Pandas", "Machine Learning", "Deep Learning"] },
  { name: "Matplotlib", category: "visualization", connections: ["Python", "Seaborn", "NumPy", "Statistics"] },
  { name: "Seaborn", category: "visualization", connections: ["Python", "Matplotlib", "Statistics", "Regression"] },
  { name: "Power BI", category: "visualization", connections: ["Excel", "SQL"] },
  { name: "Excel", category: "analytics", connections: ["Power BI", "Statistics"] },
  { name: "Tableau", category: "visualization", connections: ["SQL", "Excel"] },
  { name: "Streamlit", category: "analytics", connections: ["Python", "Pandas", "NumPy"] },


  // Statistics
  {
    name: "Statistics",
    category: "statistics",
    connections: ["R", "Python", "Hypothesis Testing", "Regression", "Time Series"],
  },
  { name: "Hypothesis Testing", category: "statistics", connections: ["R", "Statistics", "Causal Inference"] },
  { name: "Regression", category: "statistics", connections: ["R", "Statistics", "Machine Learning", "Seaborn"] },
  { name: "Time Series", category: "statistics", connections: ["R", "Statistics", "Predictive Modeling"] },
  { name: "Causal Inference", category: "statistics", connections: ["Statistics", "Hypothesis Testing"] },

  // Machine Learning
  {
    name: "Machine Learning",
    category: "ml",
    connections: ["Python", "Deep Learning", "NLP", "Predictive Modeling", "Classification", "NumPy"],
  },
  { name: "Deep Learning", category: "ml", connections: ["Python", "Machine Learning", "NLP", "NumPy"] },
  { name: "NLP", category: "ml", connections: ["Python", "Machine Learning", "Deep Learning"] },
  { name: "Predictive Modeling", category: "ml", connections: ["Machine Learning", "Time Series", "Python"] },
  { name: "Classification", category: "ml", connections: ["Machine Learning", "Java", "Anomaly Detection"] },
  { name: "Anomaly Detection", category: "ml", connections: ["Machine Learning", "Classification"] },
  { name: "Gradient Boosted Models", category: "ml", connections: ["Predictive Modeling"] },  
  { name: "PyTorch", category: "ml", connections: ["Deep Learning", "NLP"] },


  // Data Processing
  { name: "Data Mining", category: "data", connections: ["SQL", "Python", "Pandas", "MySQL"] },
  { name: "CPLEX", category: "data", connections: ["Optimization", "Python"] },
  { name: "n8n Workflows", category: "data", connections: ["APIs", "Automation"] },
  { name: "Apache Airflow", category: "data", connections: ["ETL", "Scheduling", "Python"] },
  { name: "Docker", category: "data", connections: ["DevOps", "MLflow"] },
  { name: "MLflow", category: "data", connections: ["MLOps", "PyTorch"] },

]

// Updated neon color palette with neon blue theme
const categoryColors = {
  programming: "#95f0c2",
  database: "#2a754f",
  analytics: "#027a42",
  visualization: "#52b486",
  statistics: "#0daf0d",
  ml: "#50925d",
  data: "#05f792",
}


export function FloatingSkillsBubble() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const bubblesRef = useRef<Bubble[]>([])
  const animationRef = useRef<number>()

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    const resizeCanvas = () => {
      canvas.width = canvas.offsetWidth
      canvas.height = canvas.offsetHeight
    }

    resizeCanvas()
    window.addEventListener("resize", resizeCanvas)

    // Function to check if two bubbles overlap
    const checkOverlap = (bubble1: Bubble, bubble2: Bubble) => {
      const dx = bubble1.x - bubble2.x
      const dy = bubble1.y - bubble2.y
      const distance = Math.sqrt(dx * dx + dy * dy)
      return distance < bubble1.radius + bubble2.radius + 20 // Increased buffer from 10 to 20
    }

    // Function to find a non-overlapping position with grid-based approach
    const findNonOverlappingPosition = (bubbles: Bubble[], newBubble: Bubble, maxAttempts = 100) => {
      // Try grid-based positioning first for better distribution
      const gridCols = Math.floor(canvas.width / 80) // 80px grid cells
      const gridRows = Math.floor(canvas.height / 80)
      const gridPositions = []

      for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
          gridPositions.push({
            x: (col + 0.5) * (canvas.width / gridCols),
            y: (row + 0.5) * (canvas.height / gridRows),
          })
        }
      }

      // Shuffle grid positions for randomness
      for (let i = gridPositions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1))
        ;[gridPositions[i], gridPositions[j]] = [gridPositions[j], gridPositions[i]]
      }

      // Try grid positions first
      for (const pos of gridPositions) {
        if (
          pos.x >= newBubble.radius &&
          pos.x <= canvas.width - newBubble.radius &&
          pos.y >= newBubble.radius &&
          pos.y <= canvas.height - newBubble.radius
        ) {
          newBubble.x = pos.x
          newBubble.y = pos.y

          let overlapping = false
          for (const existingBubble of bubbles) {
            if (checkOverlap(newBubble, existingBubble)) {
              overlapping = true
              break
            }
          }

          if (!overlapping) {
            return true
          }
        }
      }

      // Fallback to random positioning with more attempts
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        newBubble.x = Math.random() * (canvas.width - newBubble.radius * 2) + newBubble.radius
        newBubble.y = Math.random() * (canvas.height - newBubble.radius * 2) + newBubble.radius

        let overlapping = false
        for (const existingBubble of bubbles) {
          if (checkOverlap(newBubble, existingBubble)) {
            overlapping = true
            break
          }
        }

        if (!overlapping) {
          return true
